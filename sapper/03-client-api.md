# Client API

**Topics**
* [Introduction](./readme.md)
* [Sapper App Structure](./01-sapper-app-structure.md)
* [Routing](./02-routing.md)
* [Preloading](./04-preloading.md)
* [Layouts](./05-layouts.md)
* [Server-Side Rendering](./06-server-side-rendering.md)
* [Stores](./07-stores.md)
* [Prefetching](./08-prefetching.md)
* [Building](./09-building.md)
* [Exporting](./10-exporting.md)
* [Deployment](./11-deployment.md)
* [Security](./12-security.md)
* [Base URLs](./13-base-urls.md)
* [Testing](./14-testing.md)
* [Debugging](./15-debugging.md)
* [CSS Frameworks](./a1-css-frameworks.md)

**Contents**
* [start({ target })](#start-target-)
* [goto(href, options?)](#gotohref-options)
* [prefetch(href)](#prefetchhref)
* [prefetchRoutes(routes?)](#prefetchroutesroutes)

The `@sapper/app` module, which is generated by Sapper based on the shape of your app, contains functions for controlling Sapper programmatically and responding to events.

## start({ target })
[Back to Top](#client-api)

* `target` - an element to render pages to.

This configures the router and starts the application - listens for clicks on `<a>` elements, interacts with the `history` API, and renders and updates your Svelte components.

Returns a `Promise` that resolves when the initial page has been hydrated.

```js
imoprt * as sapper from '@sapper/app';

sapper
  .start({
    target: document.querySelector('#sapper')
  })
  .then(() => console.log('client-side app has started'));
```

## goto(href, options?)
[Back to Top](#client-api)

* `href` - the page to go to
* `option` - can include a `replaceState` property, which determines whether to use `history.pushState` (the default) or `history.replaceState`. Not required

Programmatically navigates to the given `href`. If the destination is a Sapper route, Sapper will handle the navigation, otherwise the page will be reloaded with the new `href`. In other words, the behaviour is as though the user clicked on a link with this `href`.

Returns a `Promise` that resolves when the navigation is complete. This can be used to perform actions once the navigation has completed, such as updating a database, store, etc.

```js
import { goto } from '@sapper/app';

const navigateAndSave = async () => {
  await goto('/');
  saveItem();
}

const saveItem = () => {
  // do something with the database
}
```

## prefetch(href)
[Back to Top](#client-api)

* `href` - the page to prefetch

Programatically prefetches the given page, which means:

a. ensuring that the code for the page is loaded  
b. calling the page's `preload` method with the appropriate options

This is the same behavior that Sapper triggers when the user taps or mouses over an `<a>` element with [`rel=prefetch`](./04-preloading.md).

Returns a `Promise` that resolves when the prefetch is complete.

## prefetchRoutes(routes?)
[Back to Top](#client-api)

* `routes` - an optional array of strings representing routes to prefetch.

Programatically prefetches the code for routes that haven't yet been fetched. Typically, you might call this after `sapper.start()` is complete, to speed up subsequent navigation (this is the 'L' in the [PRPL pattern](https://web.dev/apply-instant-loading-with-prpl/)). Omitting arguments will cause all routes to be fetched, or you can specify routes by any matching pathname such as `/about` (to match `src/routes/about.svelte`) or `/blog/*` (to match `src/routes/blog/[slug].svelte`). Unlike `prefetch`, this won't call `preload` for individual pages.

Returns a `Promise` that resolves when the routes have been prefetched.